#!/usr/bin/node

// npmlib-symlink-deps - create node_modules symlinks for the given module
// Copyright (C) 2018 David Shea <dshea@redhat.com>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

const fs = require('fs');
const path = require('path');
const semver = require('semver');

const npmlibPath = '/usr/lib/npm-library';

function processPeerDependency(modulePath, depName, depPath) {
  // if the dependency has peer dependencies, we can't just do a simple symlink.
  // for instance, say we have something like:
  // moduleA: { "dependencies": {"dep-framework": <version>, "dep-plugin": <version>}}
  // dep-plugin: { "peerDependencies": { "dep-framework": <version> }}
  //
  // dep-plugin expects that whatever requires dep-plugin will also require dep-framework,
  // making the framework API available from the plugin. Furthermore, we can't just treat
  // dep-framework as a dependency of dep-plugin, since pinning to a specific version of
  // dep-framework may break the version expectations for whatever requires
  // dep-framework+dep-plugin.  So for all of the require()s to work, we need
  // moduleA/node_modules to contain both dep-framework and dep-plugin, and
  // dep-plugin cannot be a symlink since it needs to be able to find
  // ../dep-framework/. Effectively, we need to bundle dep-plugin in any
  // modules that require it.

  // start by creating a directory for the plugin
  const depDest = path.join(modulePath, 'node_modules', depName);
  fs.mkdirSync(depDest);

  function copyDir(sourcePath, destPath) {
    fs.readdirSync(sourcePath).forEach((entry) => {
      const sourceFile = path.join(sourcePath, entry);
      const destFile = path.join(destPath, entry);
      const stat = fs.lstatSync(sourceFile);
      if (stat.isDirectory()) {
        // copy the directory struture and recurse
        fs.mkdirSync(destFile);
        copyDir(sourceFile, destFile);
      } else if (stat.isSymbolicLink()) {
        const target = fs.readlinkSync(sourceFile);
        fs.symlinkSync(target, destFile);
      } else {
        // copy everything else
        fs.copyFileSync(sourceFile, destFile);
      }
    });
  }

  copyDir(depPath, depDest);
}

function processDependency(modulePath, depName, depVersion) {
  const depAvailable = fs.readdirSync(path.join(npmlibPath, depName));

  // Find the max matching version
  const maxVersion = semver.maxSatisfying(depAvailable, depVersion);
  if (maxVersion === null) {
    console.error(`No version available for ${depName}@${depVersion}`);
    process.exit(1);
  }

  const depPath = path.join(npmlibPath, depName, maxVersion);
  const symlinkPath = path.join(modulePath, 'node_modules', depName);

  // read the package.json for the dependency
  const depData = JSON.parse(fs.readFileSync(path.join(depPath, 'package.json')));

  // if the dep is a scoped module, create a directory for the scope
  if (depName.indexOf('/') !== -1) {
    fs.mkdirSync(path.dirname(symlinkPath));
  }

  // if the dependency has peerDependencies, things get a little more complicated
  if ('peerDependencies' in depData) {
    processPeerDependency(modulePath, depName, depPath);
  } else {
    // Otherwise, just create a symlink
    fs.symlinkSync(path.join(npmlibPath, depName, maxVersion), symlinkPath);
  }
}

function symlinkVersion(modulePath) {
  // Create the node_modules directory
  fs.mkdirSync(path.join(modulePath, 'node_modules'));

  // Read package.json
  const packageData = JSON.parse(fs.readFileSync(path.join(modulePath, 'package.json')));

  // Process each dependency
  if (packageData.dependencies) {
    Object.entries(packageData.dependencies).forEach(([depName, depVersion]) => {
      processDependency(modulePath, depName, depVersion);
    });
  }
}

function symlinkModule(modulePath) {
  // if this is a scoped module, we need to dive one level deeper
  // otherwise, each directory we find is a module version
  let scoped = false;
  if (path.basename(modulePath).startsWith('@')) {
    scoped = true;
  }

  fs.readdirSync(modulePath).forEach((subdir) => {
    const nextPath = path.join(modulePath, subdir);
    if (scoped) {
      symlinkModule(nextPath);
    } else {
      symlinkVersion(nextPath);
    }
  });
}

// find the built modules in $RPM_BUILD_ROOT
if (process.env.RPM_BUILD_ROOT === undefined) {
  console.error('RPM_BUILD_ROOT is not set in the environment');
  process.exit(1);
}

const buildrootPath = path.join(process.env.RPM_BUILD_ROOT, npmlibPath);
try {
  fs.readdirSync(buildrootPath).forEach((subdir) => {
    const modulePath = path.join(buildrootPath, subdir);
    symlinkModule(modulePath);
  });
} catch (err) {
  process.stderr.write(`${err}\n`);
  process.exit(1);
}
