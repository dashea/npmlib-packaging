#!/usr/bin/node

// npmlib-symlink-deps - create node_modules symlinks for the given module
// Copyright (C) 2018 David Shea <dshea@redhat.com>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

const fs = require('fs');
const path = require('path');
const semver = require('semver');

const npmlibPath = '/usr/lib/npm-library';

// find the built modules in $RPM_BUILD_ROOT
if (process.env.RPM_BUILD_ROOT === undefined) {
  console.error("RPM_BUILD_ROOT is not set in the environment");
  process.exit(1);
}

const buildrootPath = path.join(process.env.RPM_BUILD_ROOT, npmlibPath);
try {
  fs.readdirSync(buildrootPath).forEach((subdir) => {
    var modulePath = path.join(buildrootPath, subdir);
    symlinkModule(modulePath);
  });
} catch (err) {
  process.stderr.write(err + '\n');
  process.exit(1);
}

function symlinkModule(modulePath) {
  // if this is a scoped module, we need to dive one level deeper
  // otherwise, each directory we find is a module version
  var scoped = false;
  if (path.basename(modulePath).startsWith('@')) {
    scoped = true;
  }

  fs.readdirSync(modulePath).forEach((subdir) => { 
    var nextPath = path.join(modulePath, subdir);
    if (scoped) {
      symlinkModule(nextPath);
    } else {
      symlinkVersion(nextPath); 
    }
  });
}

function symlinkVersion(modulePath) {
  // Create the node_modules directory
  fs.mkdirSync(path.join(modulePath, 'node_modules'));

  // Read package.json
  var packageData = JSON.parse(fs.readFileSync(path.join(modulePath, 'package.json')));

  // Process each dependency
  if (packageData.dependencies) {
    Object.entries(packageData.dependencies).forEach(([depName, depVersion]) => {
      processDependency(modulePath, depName, depVersion);
    });
  }
}

function processDependency(modulePath, depName, depVersion) {
  var depAvailable = fs.readdirSync(path.join(npmlibPath, depName));

  // Find the max matching version
  var maxVersion = semver.maxSatisfying(depAvailable, depVersion);
  if (maxVersion === null) {
    console.error("No version available for " + depName + "@" + depVersion);
    process.exit(1);
  }

  var symlinkPath = path.join(modulePath, 'node_modules', depName);

  // if the dep is a scoped module, create a directory for the scope
  if (depName.indexOf('/') !== -1) {
    fs.mkdirSync(path.dirname(symlinkPath));
  }

  // Create the symlink
  fs.symlinkSync(path.join(npmlibPath, depName, maxVersion), symlinkPath);
}
